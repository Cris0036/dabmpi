/* 
 * File:   main.cpp
 * Author: antonio
 *
 * Created on 6 de octubre de 2011, 8:25
 */

#include <stdlib.h>
#include <string>
#include <iostream>
#include <fstream>
#include <vector>
#include <math.h>
//#include "boost/multi_array.hpp"
#include "silo.h"

using namespace std;

#define SIZENAME 16
#define NBDIM 3

struct mnstruct {
  int m, n;
};


int main(int argc, char** argv) {

  ifstream myfile;
  ofstream outfile;
  string dump, version;
  int ns, nmax;
  vector <mnstruct>  mn;
  vector <double> r;
  vector <double> z;
  vector <double> b;
  mnstruct lineamn;
  double temprmn, tempzmn, tempbmn;
  int *connectivity;

  if (argc<2) {
    cout<<"Incorrect number of arguments";
    return -1;
  }

  myfile.open (argv[1]);
  //myfile.open ("/home/antonio/Escritorio/wout.txt");
  if (!myfile.is_open()) return -1;
  myfile >> dump >> dump >> dump >> version;

  if (version != "8.46") {
    cout << "Incorrect version";
    return -1;
  }
  cout << "VMEC Version: " << version << endl;
  for (int i = 0; i<4; i++)  getline (myfile, dump);

  myfile >> dump >> ns >> dump >> dump >> nmax >> dump;

  for (int i = 0; i<4; i++)  getline (myfile, dump);

  for (int i = 0; i < ns; i++ ) {
    for (int j=0; j<nmax ; j++) {
      if (i==0) {
        myfile >> lineamn.m >> lineamn.n;
        mn.push_back (lineamn);
        getline (myfile, dump);
        
        myfile >> temprmn >> tempzmn >> dump;
        r.push_back (temprmn);
        z.push_back (tempzmn);
        getline (myfile, dump);
        
      }
    }
    for (int j=0; j<nmax; j++) {
      if (i==0)  getline (myfile, dump);
      myfile >> tempbmn >> dump >> dump;
      b.push_back(tempbmn);
      for (int k = 0; k<3; k++)  getline (myfile, dump);
    }
  }
  myfile.close();

  cout << "wout file read" << endl;

  outfile.open ("wout_transform.txt"); 
  std::vector < std::vector < std::vector<float> > > valr, valz, valb;
  valr.resize (ns);
  valz.resize (ns);
  valb.resize (ns);
/*
  typedef boost::multi_array<double, 3> array_type;
  typedef array_type::index index;
  array_type valr(boost::extents[ns][360][360]);
  array_type valz(boost::extents[ns][360][360]);
  array_type valb(boost::extents[ns][360][360]);
*/
  for (int ins = 1 ; ins < ns; ins++) {
    cout << "Transforming surface " << ins << endl;
    valr[ins].resize (360);
    valz[ins].resize (360);
    valb[ins].resize (360);
    for (int phi = 0; phi <360; phi++){
      valr[ins][phi].resize (360, 0.0);
      valz[ins][phi].resize (360, 0.0);
      valb[ins][phi].resize (360, 0.0);
      for (int rho = 0; rho < 360; rho++) {
       // double valr, valz, valb;
       // valr=0.0; valz=0.0; valb=0.0;
        for (int i = 0; i<nmax; i++) {
          valr[ins][phi][rho]+=r[ns*ins+i]* cos(mn[i].m*rho*M_PI/180-mn[i].n*phi*M_PI/180);
          valz[ins][phi][rho]+=z[ns*ins+i]* sin(mn[i].m*rho*M_PI/180-mn[i].n*phi*M_PI/180);
          valb[ins][phi][rho]+=b[ns*ins+i]* cos(mn[i].m*rho*M_PI/180-mn[i].n*phi*M_PI/180);
        }
        outfile << valr[ins][phi][rho] << "\t" << valz[ins][phi][rho] << "\t" << phi << "\t" << rho << endl;
      }
    }
  }

  outfile.close();

  cout << "All surfaces transformed" << endl;

  outfile.open ("wout.lines");

  char meshname[256], zonelistname[256],varname[256];
  DBfile *dbfile = NULL;
  dbfile = DBCreate("wout.silo", DB_CLOBBER, DB_LOCAL, "file generated by stel2silo.c", DB_HDF5);
  float *coord[NBDIM]; // Pointer to the structured mesh
  int shapetype[1];
  int shapesize[1];
  int shapecounts[1];
  int nshapetypes;
  shapetype[0] = DB_ZONETYPE_TRIANGLE; //We have only line segments
  shapesize[0] = 3;                    // A triangle has 3 vertices
  shapecounts[0] = 2*360*360;             // There are nzones triangles
  nshapetypes = 1;
  
  float* xcart = new float[360*360];
  float* ycart = new float[360*360];
  float* zcart = new float[360*360];
  float* bcart = new float[360*360];
  coord[0] = xcart;
  coord[1] = ycart;
  coord[2] = zcart;

  int off0 = 360;
  connectivity = new int [3*2*360*360];
  for(int j=0; j < 360; ++j) {
    for(int i=0; i < 360; ++i) {
      int cur_index = i + off0*j;
			connectivity[6*cur_index] = cur_index;
			connectivity[6*cur_index+1] = (i+1)%360 + off0*j;
			connectivity[6*cur_index+2] = i + off0*((j+1)%360);

			connectivity[6*cur_index+3] = (i+1)%360 + off0*j;
			connectivity[6*cur_index+4] = (i+1)%360 + off0*((j+1)%360);
			connectivity[6*cur_index+5] = i + off0*((j+1)%360);
    }
  }

  for (int ins = 1; ins < ns; ins+=5) {
    cout << "Silo surface " << ins << endl;
    for (int phi = 0; phi <360; phi++){
      for (int rho = 0; rho < 360; rho++) {
        xcart[rho+360*phi]= valr[ins][phi][rho]*cos(phi*M_PI/180);
        ycart[rho+360*phi]= valr[ins][phi][rho]*sin(phi*M_PI/180);
        zcart[rho+360*phi]= valz[ins][phi][rho];
        bcart[rho+360*phi]= 0.0;
        outfile << xcart[rho+360*phi] << ',' << ycart[rho+360*phi] << ',' << zcart[rho+360*phi] << endl;
      }
    }
    //Data export

   	
    sprintf(zonelistname, "zone_list%d", ins);
    sprintf(meshname, "surface%d", ins);
    sprintf(varname, "surface%d", ins);
    DBPutZonelist2(dbfile, zonelistname, 2*360*360, 3, connectivity, 3*2*360*360, 0, 0, 0, shapetype, shapesize, shapecounts, nshapetypes, NULL);
    DBPutUcdmesh(dbfile, meshname, 3, NULL, coord, 360*360, 2*360*360, zonelistname, NULL, DB_FLOAT, NULL);
    DBPutUcdvar1(dbfile,varname ,meshname, (float*)bcart, 360*360, NULL, 0, DB_DOUBLE, DB_NODECENT, NULL);
    cout << "Surface " << ins << " added" << endl;

  }
  outfile.close();
  free (connectivity);
  return (EXIT_SUCCESS);
}

